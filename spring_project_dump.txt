

--- File: .mvn\wrapper\maven-wrapper.properties ---
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\TicketServiceManagementV100Application.java ---
package ticketmanagement.ticketservicemanagementv100;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TicketServiceManagementV100Application {
    public static void main(String[] args) {
        SpringApplication.run(TicketServiceManagementV100Application.class, args);
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\config\CorsConfig.java ---
package ticketmanagement.ticketservicemanagementv100.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;

@Configuration
public class CorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(false);
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(Arrays.asList("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\AdminController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.entity.TicketCategory;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.service.TicketCategoryService;
import ticketmanagement.ticketservicemanagementv100.service.UserService;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class AdminController {
    private final UserService userService;
    private final TicketCategoryService categoryService;

    @PostMapping("/customers")
    public ResponseEntity<Map<String, Object>> createCustomer(@RequestBody User customer, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            customer.setRole(UserRole.CUSTOMER);
            customer.setIsDefaultEngineer(false);

            User createdCustomer = userService.createUser(customer);
            response.put("success", true);
            response.put("customer", createdCustomer);
            response.put("message", "Customer created successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (RuntimeException e) {
            response.put("success", false);
            response.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/engineers")
    public ResponseEntity<Map<String, Object>> createEngineer(@RequestBody User engineer, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            engineer.setRole(UserRole.ENGINEER);
            engineer.setIsDefaultEngineer(false);

            User createdEngineer = userService.createUser(engineer);
            response.put("success", true);
            response.put("engineer", createdEngineer);
            response.put("message", "Engineer created successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (RuntimeException e) {
            response.put("success", false);
            response.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/customers")
    public ResponseEntity<Map<String, Object>> getAllCustomers(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            List<User> customers = userService.findByRole(UserRole.CUSTOMER);
            response.put("success", true);
            response.put("customers", customers);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching customers: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PostMapping("/categories")
    public ResponseEntity<Map<String, Object>> createCategory(@RequestBody TicketCategory category, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            TicketCategory createdCategory = categoryService.createCategory(category);
            response.put("success", true);
            response.put("category", createdCategory);
            response.put("message", "Category created successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (RuntimeException e) {
            response.put("success", false);
            response.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/categories")
    public ResponseEntity<Map<String, Object>> getAllCategories(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            List<TicketCategory> categories = categoryService.getAllCategories();
            response.put("success", true);
            response.put("categories", categories);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching categories: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\AuthController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.service.UserService;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class AuthController {
    private final UserService userService;

    @PostMapping("/login")
    public ResponseEntity<Map<String, Object>> login(@RequestBody Map<String, String> credentials, HttpSession session) {
        Map<String, Object> response = new HashMap<>();

        try {
            String username = credentials.get("username");
            String password = credentials.get("password");

            User user = userService.authenticate(username, password);
            if (user != null) {
                session.setAttribute("currentUser", user);
                response.put("success", true);
                response.put("user", user);
                response.put("role", user.getRole().toString());
                response.put("message", "Login successful");
                return ResponseEntity.ok(response);
            }

            response.put("success", false);
            response.put("message", "Invalid credentials");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);

        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Login failed: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PostMapping("/logout")
    public ResponseEntity<Map<String, Object>> logout(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        try {
            session.invalidate();
            response.put("success", true);
            response.put("message", "Logout successful");
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Logout failed");
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @GetMapping("/current-user")
    public ResponseEntity<Map<String, Object>> getCurrentUser(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser != null) {
            response.put("success", true);
            response.put("user", currentUser);
            return ResponseEntity.ok(response);
        }

        response.put("success", false);
        response.put("message", "No user logged in");
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\CustomerController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import ticketmanagement.ticketservicemanagementv100.entity.*;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;
import ticketmanagement.ticketservicemanagementv100.service.*;

import jakarta.servlet.http.HttpSession;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/customer")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class CustomerController {
    private final TicketService ticketService;
    private final CommentService commentService;
    private final AttachmentService attachmentService;
    private final UserService userService;
    private final TicketCategoryService categoryService;

    @PostMapping("/tickets")
    public ResponseEntity<Map<String, Object>> createTicket(@RequestBody Ticket ticket, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            ticket.setCustomer(currentUser);
            Ticket createdTicket = ticketService.createTicket(ticket);
            response.put("success", true);
            response.put("ticket", createdTicket);
            response.put("message", "Ticket created successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error creating ticket: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @GetMapping("/tickets")
    public ResponseEntity<Map<String, Object>> getMyTickets(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            List<Ticket> tickets = ticketService.getTicketsForUser(currentUser);
            response.put("success", true);
            response.put("tickets", tickets);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching tickets: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @GetMapping("/tickets/search")
    public ResponseEntity<Map<String, Object>> searchMyTickets(
            @RequestParam(required = false) TicketStatus status,
            @RequestParam(required = false) Long categoryId,
            HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            List<Ticket> tickets = ticketService.searchTickets(status, categoryId, null, currentUser);
            response.put("success", true);
            response.put("tickets", tickets);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error searching tickets: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PostMapping("/tickets/{ticketId}/comments")
    public ResponseEntity<Map<String, Object>> addComment(@PathVariable Long ticketId, @RequestBody Comment comment, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            Ticket ticket = ticketService.findById(ticketId);
            if (ticket == null || !ticket.getCustomer().getId().equals(currentUser.getId())) {
                response.put("success", false);
                response.put("message", "Ticket not found or access denied");
                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
            }

            comment.setTicket(ticket);
            comment.setAuthor(currentUser);
            Comment savedComment = commentService.addComment(comment);
            response.put("success", true);
            response.put("comment", savedComment);
            response.put("message", "Comment added successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error adding comment: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PostMapping("/tickets/{ticketId}/attachments")
    public ResponseEntity<Map<String, Object>> uploadAttachment(
            @PathVariable Long ticketId,
            @RequestParam("file") MultipartFile file,
            @RequestParam(required = false) String comment,
            HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            Ticket ticket = ticketService.findById(ticketId);
            if (ticket == null || !ticket.getCustomer().getId().equals(currentUser.getId())) {
                response.put("success", false);
                response.put("message", "Ticket not found or access denied");
                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
            }

            Attachment attachment = attachmentService.saveAttachment(file, ticket, comment, currentUser);
            response.put("success", true);
            response.put("attachment", attachment);
            response.put("message", "File uploaded successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (IOException e) {
            response.put("success", false);
            response.put("message", "Error uploading file: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @GetMapping("/categories")
    public ResponseEntity<Map<String, Object>> getCategories() {
        Map<String, Object> response = new HashMap<>();
        try {
            List<TicketCategory> categories = categoryService.getAllCategories();
            response.put("success", true);
            response.put("categories", categories);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching categories: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PutMapping("/profile")
    public ResponseEntity<Map<String, Object>> updateProfile(@RequestBody User updatedUser, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            currentUser.setFullName(updatedUser.getFullName());
            currentUser.setEmail(updatedUser.getEmail());
            currentUser.setPhoneNumber(updatedUser.getPhoneNumber());

            User savedUser = userService.updateUser(currentUser);
            session.setAttribute("currentUser", savedUser);
            response.put("success", true);
            response.put("user", savedUser);
            response.put("message", "Profile updated successfully");
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error updating profile: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\EngineerController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.service.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/engineer")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class EngineerController {
    private final TicketService ticketService;
    private final CommentService commentService;
    private final AttachmentService attachmentService;
    private final UserService userService;
    private final TicketCategoryService categoryService;

    @GetMapping("/tickets")
    public ResponseEntity<Map<String, Object>> getAllTickets(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            List<Ticket> tickets = ticketService.getTicketsForUser(currentUser);
            response.put("success", true);
            response.put("tickets", tickets);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching tickets: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @GetMapping("/tickets/unassigned")
    public ResponseEntity<Map<String, Object>> getUnassignedTickets() {
        Map<String, Object> response = new HashMap<>();
        try {
            List<Ticket> tickets = ticketService.getUnassignedTickets();
            response.put("success", true);
            response.put("tickets", tickets);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching unassigned tickets: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PostMapping("/tickets/{ticketId}/acknowledge")
    public ResponseEntity<Map<String, Object>> acknowledgeTicket(@PathVariable Long ticketId, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            Ticket ticket = ticketService.acknowledgeTicket(ticketId, currentUser);
            if (ticket != null) {
                response.put("success", true);
                response.put("ticket", ticket);
                response.put("message", "Ticket acknowledged successfully");
                return ResponseEntity.ok(response);
            }
            response.put("success", false);
            response.put("message", "Unable to acknowledge ticket");
            return ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error acknowledging ticket: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PutMapping("/tickets/{ticketId}")
    public ResponseEntity<Map<String, Object>> updateTicket(@PathVariable Long ticketId, @RequestBody Ticket updatedTicket, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            Ticket ticket = ticketService.findById(ticketId);
            if (ticket == null) {
                response.put("success", false);
                response.put("message", "Ticket not found");
                return ResponseEntity.badRequest().body(response);
            }

            // Update allowed fields
            ticket.setStatus(updatedTicket.getStatus());
            ticket.setDescription(updatedTicket.getDescription());
            ticket.setTentativeResolutionDate(updatedTicket.getTentativeResolutionDate());
            if (updatedTicket.getAssignedEngineer() != null) {
                ticket.setAssignedEngineer(updatedTicket.getAssignedEngineer());
            }

            Ticket savedTicket = ticketService.updateTicket(ticket);
            response.put("success", true);
            response.put("ticket", savedTicket);
            response.put("message", "Ticket updated successfully");
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error updating ticket: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @DeleteMapping("/tickets/{ticketId}")
    public ResponseEntity<Map<String, Object>> deleteTicket(@PathVariable Long ticketId) {
        Map<String, Object> response = new HashMap<>();
        try {
            ticketService.deleteTicket(ticketId);
            response.put("success", true);
            response.put("message", "Ticket deleted successfully");
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error deleting ticket: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @GetMapping("/tickets/search")
    public ResponseEntity<Map<String, Object>> searchTickets(
            @RequestParam(required = false) TicketStatus status,
            @RequestParam(required = false) Long categoryId,
            @RequestParam(required = false) String customerName,
            HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null) {
            response.put("success", false);
            response.put("message", "Not authenticated");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
        }

        try {
            List<Ticket> tickets = ticketService.searchTickets(status, categoryId, customerName, currentUser);
            response.put("success", true);
            response.put("tickets", tickets);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error searching tickets: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @GetMapping("/engineers")
    public ResponseEntity<Map<String, Object>> getAllEngineers() {
        Map<String, Object> response = new HashMap<>();
        try {
            List<User> engineers = userService.findByRole(UserRole.ENGINEER);
            response.put("success", true);
            response.put("engineers", engineers);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching engineers: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\HomeController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HomeController {

    @GetMapping("/")
    public String home() {
        return "Welcome to the Home Page!";
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\LoginController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.dto.LoginRequest;
import ticketmanagement.ticketservicemanagementv100.dto.LoginResponseDTO;
import ticketmanagement.ticketservicemanagementv100.entity.*;
import ticketmanagement.ticketservicemanagementv100.service.LoginService;

import java.util.Optional;

@RestController
@RequestMapping("/login")
@RequiredArgsConstructor
public class LoginController {

    private final LoginService loginService;

    @PostMapping
    public ResponseEntity<LoginResponseDTO> login(@RequestBody LoginRequest loginRequest) {
        Optional<User> optionalUser = loginService.authenticate(loginRequest.getUsername(), loginRequest.getPassword());

        if (optionalUser.isPresent()) {
            User user = optionalUser.get();
            LoginResponseDTO response = new LoginResponseDTO(
                    user.getUsername(),
                    user.getRole().name(),
                    "Login successful"
            );
            return ResponseEntity.ok(response);
        }

        // If authentication fails
        LoginResponseDTO errorResponse = new LoginResponseDTO(
                loginRequest.getUsername(),
                "UNKNOWN",
                "Invalid username or password"
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\TicketController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.dto.TicketCreationDTO;
import ticketmanagement.ticketservicemanagementv100.dto.TicketUpdateDTO;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.repository.CustomerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.TicketRepository;
import ticketmanagement.ticketservicemanagementv100.service.TicketService;

import java.util.List;

/**
 * REST Controller for managing Ticket resources.
 * This controller handles HTTP requests related to tickets,
 * delegating business logic to the TicketService.
 * <p>
 * Updated: Changed base request mapping to "/api/tickets" to match frontend.
 */
@RestController
@RequestMapping("/api/tickets") // Changed to /api/tickets
@RequiredArgsConstructor
public class TicketController {

    private final TicketService ticketService; // Inject the service
    private final CustomerRepository customerRepo;
    private final EngineerRepository engineerRepo;
    private final TicketRepository ticketRepo;

    /**
     * Creates a new Ticket using a TicketCreationDTO.
     * This endpoint expects a DTO containing the ticket description,
     * the customerId, and an optional engineerId for immediate assignment.
     *
     * @param ticketDto The TicketCreationDTO object containing description, customerId, and optional engineerId.
     * @param username  The username of the customer creating the ticket (from X-Username header).
     * @param role      The role of the user (from X-User-Role header).
     * @return ResponseEntity containing the created Ticket and HTTP status 201 (Created).
     */
    @PostMapping
    public ResponseEntity<Ticket> createTicket(@RequestBody TicketCreationDTO ticketDto,
                                               @RequestHeader("X-Username") String username,
                                               @RequestHeader("X-User-Role") String role) {
        if (!"CUSTOMER".equalsIgnoreCase(role)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        if (ticketDto.getDescription() == null || ticketDto.getDescription().trim().isEmpty()) {
            return ResponseEntity.badRequest().body(null);
        }

        Customer customer = customerRepo.findByUsername(username)
                .orElseThrow(() -> new EntityNotFoundException("Customer not found"));

        Ticket savedTicket = ticketService.createTicket(
                customer.getId(),
                ticketDto.getDescription(),
                ticketDto.getEngineerId()
        );

        return new ResponseEntity<>(savedTicket, HttpStatus.CREATED);
    }


    /**
     * Retrieves all Tickets.
     *
     * @return ResponseEntity containing a list of all Tickets and HTTP status 200 (OK).
     */
    @GetMapping
    public ResponseEntity<List<Ticket>> getAllTickets() {
        List<Ticket> tickets = ticketService.getAllTickets();
        return ResponseEntity.ok(tickets);
    }

    /**
     * Retrieves a Ticket by its ID.
     *
     * @param id The ID of the ticket to retrieve.
     * @return ResponseEntity containing the Ticket if found (HTTP 200 OK),
     * or HTTP status 404 (Not Found) if not found.
     */
    @GetMapping("/{id}")
    public ResponseEntity<Ticket> getTicketById(@PathVariable Long id) {
        return ticketService.getTicketById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Updates an existing Ticket.
     *
     * @param id  The ID of the ticket to update.
     * @param dto The Ticket object with updated details.
     * @return ResponseEntity containing the updated Ticket (HTTP 200 OK),
     * or HTTP status 404 (Not Found) if the ticket does not exist.
     */
    @PutMapping("/{id}")
    public ResponseEntity<Ticket> updateTicket(@PathVariable Long id,
                                               @RequestBody TicketUpdateDTO dto) {
        try {
            Ticket ticket = ticketService.getTicketById(id)
                    .orElseThrow(() -> new EntityNotFoundException("Ticket not found"));

            if (dto.getEngineerId() != null) {
                Engineer engineer = engineerRepo.findById(dto.getEngineerId())
                        .orElseThrow(() -> new EntityNotFoundException("Engineer not found"));
                ticket.setAcknowledgedBy(engineer);
            }

            ticket.setDescription(dto.getDescription());
            ticket.setStatus(dto.getStatus());
            ticket.setTentativeResolutionDate(dto.getTentativeResolutionDate());
            ticket.setCustomerCommentOnTicket(dto.getCustomerCommentOnTicket());
            ticket.setEngineerCommentOnTicket(dto.getEngineerCommentOnTicket());

            Ticket updated = ticketRepo.save(ticket);
            return ResponseEntity.ok(updated);

        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }


    /**
     * Deletes a Ticket by its ID.
     *
     * @param id   The ID of the ticket to delete.
     * @param role The role of the user (from X-User-Role header).
     * @return ResponseEntity with HTTP status 200 (OK) if deleted successfully,
     * or HTTP status 404 (Not Found) if the ticket does not exist.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTicket(@PathVariable Long id,
                                             @RequestHeader("X-User-Role") String role) {
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN);
        }
        ticketService.deleteTicket(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    /**
     * Acknowledges a ticket by assigning the currently logged-in engineer.
     * The engineer's username is retrieved from the X-Username header.
     *
     * @param ticketId         The ID of the ticket to acknowledge.
     * @param engineerUsername The username of the engineer acknowledging the ticket (from X-Username header).
     * @return ResponseEntity containing the acknowledged Ticket (HTTP 200 OK),
     * or HTTP status 404 (Not Found) if ticket or engineer does not exist.
     * @return ResponseEntity with HTTP status 403 (Forbidden) if the user is not an ENGINEER.
     */
    @PutMapping("/{ticketId}/acknowledge") // Modified endpoint: removed {engineerId} from path
    public ResponseEntity<Ticket> acknowledgeTicket(
            @PathVariable Long ticketId,
            @RequestHeader("X-Username") String engineerUsername, // Get username from header
            @RequestHeader("X-User-Role") String role) { // Get role from header for validation
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }
        try {
            // Call service method with username
            Ticket acknowledgedTicket = ticketService.acknowledgeTicket(ticketId, engineerUsername);
            return ResponseEntity.ok(acknowledgedTicket);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get tickets created by a specific customer (by username)
     * Called by frontend: GET /api/tickets/customer/{username}
     */
    @GetMapping("/customer/{username}")
    public ResponseEntity<List<Ticket>> getTicketsByCustomer(
            @PathVariable String username,
            @RequestHeader("X-Username") String requestUsername,
            @RequestHeader("X-User-Role") String role) {

        // Security check: ensure customer can only access their own tickets
        if (!"CUSTOMER".equalsIgnoreCase(role) || !username.equals(requestUsername)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            Customer customer = customerRepo.findByUsername(username)
                    .orElseThrow(() -> new EntityNotFoundException("Customer not found"));

            List<Ticket> tickets = ticketRepo.findByCreatedById(customer.getId());
            return ResponseEntity.ok(tickets);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get tickets assigned to a specific engineer (by username)
     * Called by frontend: GET /api/tickets/engineer/{username}
     */
    @GetMapping("/engineer/{username}")
    public ResponseEntity<List<Ticket>> getTicketsByEngineer(
            @PathVariable String username,
            @RequestHeader("X-Username") String requestUsername,
            @RequestHeader("X-User-Role") String role) {

        // Security check: ensure engineer can only access their own assigned tickets
        if (!"ENGINEER".equalsIgnoreCase(role) || !username.equals(requestUsername)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            Engineer engineer = engineerRepo.findByUsername(username)
                    .orElseThrow(() -> new EntityNotFoundException("Engineer not found"));

            List<Ticket> tickets = ticketRepo.findByAcknowledgedById(engineer.getId());
            return ResponseEntity.ok(tickets);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\CategoryDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CategoryDTO {

    private String name;
    private String description;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\CommentDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;


@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CommentDTO {

    private String content;
    private Long ticketId;
    private Long authorId;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\CustomerRegistrationDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Data Transfer Object (DTO) for registering a new Customer.
 * This DTO is used when an Engineer creates a new Customer account.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CustomerRegistrationDTO{
        private String username;
        private String password;
        private String email;
        private String phoneNumber;
        private String address;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\CustomerResponseDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class CustomerResponseDTO {
    private Long id;
    private String username;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\EngineerRegistrationDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO for creating a new Engineer.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class EngineerRegistrationDTO {
    private String username;
    private String password;
    private String email;
    private String specialization;
    private boolean isDefaultEngineer;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\EngineerResponseDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class EngineerResponseDTO {
    private Long id;
    private String username;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\LoginRequestDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Data Transfer Object (DTO) for user login requests.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequestDTO {
    private String username;
    private String password;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\LoginResponseDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO for login responses.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponseDTO {
    private String username;
    private String role;
    private String message;
    private boolean success;
    private Long id;
    private String fullName;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\TicketCreationDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
/*
 * Data Transfer Object (DTO) for creating a new Ticket.
 * This class defines the minimal set of information required from the client
 * to create a ticket. The customerId will now be explicitly provided.
 * It still includes an optional engineerId for immediate assignment.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class TicketCreationDTO {
    private String description;
   // private Long customerId; // Uncommented to allow direct passing of customerId
    private Long engineerId;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\TicketUpdateDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;

import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class TicketUpdateDTO {
    private String description;
    private TicketStatus status;
    private Long categoryId;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\Attachment.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "attachments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Attachment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String fileName;

    @Column(nullable = false)
    private String filePath;

    private String fileType;

    private Long fileSize;

    private String comment;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ticket_id", nullable = false)
    @JsonIgnoreProperties({"comments", "attachments", "customer", "assignedEngineer"})
    private Ticket ticket;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "uploaded_by", nullable = false)
    @JsonIgnoreProperties({"createdTickets", "assignedTickets"})
    private User uploadedBy;

    @Column(nullable = false)
    private LocalDateTime uploadedAt = LocalDateTime.now();
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\Comment.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Entity
@Table(name = "comments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Comment{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ticket_id", nullable = false)
    @JsonIgnoreProperties({"comments", "attachments", "customer", "assignedEngineer"})
    private Ticket ticket;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "author_id", nullable = false)
    @JsonIgnoreProperties({"createdTickets", "assignedTickets"})
    private User author;

    @Column(nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\Customer.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "customers")
@PrimaryKeyJoinColumn(name = "user_id")
@Data
@EqualsAndHashCode(callSuper = true)
public class Customer extends User {
    private String phoneNumber;
    private String address;

    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL)
    private List<Ticket> tickets = new ArrayList<>();
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\Engineer.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.OneToMany;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "engineers")
@PrimaryKeyJoinColumn(name = "user_id")
@Data
@EqualsAndHashCode(callSuper = true)
public class Engineer extends User {
    private String specialization;
    private boolean isDefaultEngineer = false;

    @OneToMany(mappedBy = "assignedEngineer")
    private List<Ticket> assignedTickets = new ArrayList<>();
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\Ticket.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;
import ticketmanagement.ticketservicemanagementv100.entity.TicketCategory;

import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "tickets")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TicketStatus status = TicketStatus.CREATED;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "customer_id", nullable = false)
    @JsonIgnoreProperties({"createdTickets", "assignedTickets"})
    private User customer;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "assigned_engineer_id")
    @JsonIgnoreProperties({"createdTickets", "assignedTickets"})
    private User assignedEngineer;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "category_id")
    private TicketCategory category;

    private LocalDateTime tentativeResolutionDate;

    @Column(nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(nullable = false)
    private LocalDateTime updatedAt = LocalDateTime.now();

    @OneToMany(mappedBy = "ticket", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Comment> comments;

    @OneToMany(mappedBy = "ticket", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Attachment> attachments;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\TicketCategory.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Entity
@Table(name = "ticket_categories")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TicketCategory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name;

    private String description;

    @OneToMany(mappedBy = "category", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private List<Ticket> tickets;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\User.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.*;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;

import java.time.LocalDateTime;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String fullName;

    @Column(nullable = false)
    private String email;

    //private String phoneNumber;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserRole role;

    @Column(nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(nullable = false)
    private LocalDateTime updatedAt = LocalDateTime.now();
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\enums\TicketStatus.java ---
package ticketmanagement.ticketservicemanagementv100.enums;

public enum TicketStatus {
    CREATED, ACKNOWLEDGED, IN_PROGRESS, CLOSED
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\enums\UserRole.java ---
package ticketmanagement.ticketservicemanagementv100.enums;

public enum UserRole {
    CUSTOMER, ENGINEER
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\AttachmentRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import ticketmanagement.ticketservicemanagementv100.entity.Attachment;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AttachmentRepository extends JpaRepository<Attachment, Long> {
    List<Attachment> findByTicket(Ticket ticket);
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\CommentRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import ticketmanagement.ticketservicemanagementv100.entity.*;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByTicketOrderByCreatedAtAsc(Ticket ticket);
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\CustomerRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmanagement.ticketservicemanagementv100.entity.Customer;

import java.util.Optional;

public interface CustomerRepository extends JpaRepository<Customer, Long> {
    Optional<Customer> findByUsername(String username);

    Optional<Customer> findByEmail(String email);

}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\EngineerRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmanagement.ticketservicemanagementv100.entity.Engineer;

import java.util.List;
import java.util.Optional;

public interface EngineerRepository extends JpaRepository<Engineer, Long> {
    Optional<Engineer> findByUsername(String username); // New method for finding engineer by username

    Optional<Engineer> findByEmail(String email);

    Optional<Engineer> findByIsDefaultEngineer(boolean isDefault);

    List<Engineer> findByIsDefaultEngineerFalse();
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\TicketCategoryRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import ticketmanagement.ticketservicemanagementv100.entity.TicketCategory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface TicketCategoryRepository extends JpaRepository<TicketCategory, Long> {
    Optional<TicketCategory> findByName(String name);
    boolean existsByName(String name);
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\TicketRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;

import java.util.List;

@Repository
public interface TicketRepository extends JpaRepository<Ticket, Long> {

    List<Ticket> findByCustomer(User customer);

    List<Ticket> findByAssignedEngineer(User engineer);

    List<Ticket> findByAssignedEngineerIsNull();

    List<Ticket> findByStatus(TicketStatus status);

    List<Ticket> findByCategory_Id(Long categoryId);

}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\UserRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);

    Optional<User> findByUsernameAndPassword(String username, String password);

    List<User> findByRole(UserRole role);

    Optional<User> findByIsDefaultEngineerTrue();

    boolean existsByUsername(String username);

    boolean existsByEmail(String email);
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\AttachmentService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import ticketmanagement.ticketservicemanagementv100.entity.Attachment;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.repository.AttachmentRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class AttachmentService {
    private final AttachmentRepository attachmentRepository;
    private final String uploadDir = "uploads/";
    
    public Attachment saveAttachment(MultipartFile file, Ticket ticket, String comment, User uploadedBy) throws IOException {
        // Create upload directory if it doesn't exist
        File directory = new File(uploadDir);
        if (!directory.exists()) {
            directory.mkdirs();
        }
        
        // Generate unique filename
        String fileName = UUID.randomUUID().toString() + "_" + file.getOriginalFilename();
        Path filePath = Paths.get(uploadDir + fileName);
        
        // Save file to disk
        Files.write(filePath, file.getBytes());
        
        // Create attachment entity
        Attachment attachment = new Attachment();
        attachment.setFileName(file.getOriginalFilename());
        attachment.setFilePath(filePath.toString());
        attachment.setFileType(file.getContentType());
        attachment.setFileSize(file.getSize());
        attachment.setComment(comment);
        attachment.setTicket(ticket);
        attachment.setUploadedBy(uploadedBy);
        attachment.setUploadedAt(LocalDateTime.now());
        
        return attachmentRepository.save(attachment);
    }
    
    public List<Attachment> getAttachmentsByTicket(Ticket ticket) {
        return attachmentRepository.findByTicket(ticket);
    }
    
    public Attachment findById(Long id) {
        return attachmentRepository.findById(id).orElse(null);
    }
    
    public byte[] downloadAttachment(Long attachmentId) throws IOException {
        Attachment attachment = findById(attachmentId);
        if (attachment != null) {
            Path filePath = Paths.get(attachment.getFilePath());
            return Files.readAllBytes(filePath);
        }
        return null;
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\CommentService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.entity.Comment;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.repository.CommentRepository;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class CommentService {
    private final CommentRepository commentRepository;

    public Comment addComment(Comment comment) {
        comment.setCreatedAt(LocalDateTime.now());
        return commentRepository.save(comment);
    }

    public List<Comment> getCommentsByTicket(Ticket ticket) {
        return commentRepository.findByTicketOrderByCreatedAtAsc(ticket);
    }

    public Comment findById(Long id) {
        return commentRepository.findById(id).orElse(null);
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\CustomerService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.dto.CustomerRegistrationDTO;
import ticketmanagement.ticketservicemanagementv100.entity.Customer;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.CustomerRepository;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class CustomerService {

    private final CustomerRepository customerRepository;

    public List<Customer> getAllCustomers() {
        return customerRepository.findAll();
    }

    /**
     * Retrieves a Customer by their ID.
     *
     * @param id The ID of the customer to retrieve.
     * @return An Optional containing the Customer if found, or empty if not.
     */
    public Optional<Customer> getCustomerById(Long id) {
        return customerRepository.findById(id);
    }

    /**
     * Updates an existing Customer.
     *
     * @param id              The ID of the customer to update.
     * @param customerDetails The Customer object containing updated details.
     * @return The updated Customer object.
     * @throws EntityNotFoundException if no customer with the given ID is found.
     */
    public Customer updateCustomer(Long id, Customer customerDetails) {
        return customerRepository.findById(id)
                .map(customer -> {
                    customer.setUsername(customerDetails.getUsername());
                    customer.setPassword(customerDetails.getPassword());
                    return customerRepository.save(customer);
                })
                .orElseThrow(() -> new EntityNotFoundException("Customer not found with id " + id));
    }

    /**
     * Deletes a Customer by their ID.
     *
     * @param id The ID of the customer to delete.
     * @throws EntityNotFoundException if no customer with the given ID is found.
     */
    public void deleteCustomer(Long id) {
        if (!customerRepository.existsById(id)) {
            throw new EntityNotFoundException("Customer not found with id " + id);
        }
        customerRepository.deleteById(id);
    }

    public Customer registerCustomerFromDTO(CustomerRegistrationDTO dto) {
        if (dto.getUsername() == null || dto.getPassword() == null ||
                dto.getUsername().isBlank() || dto.getPassword().isBlank()) {
            throw new IllegalArgumentException("Username and password must not be blank.");
        }

        Customer customer = new Customer();
        customer.setUsername(dto.getUsername());
        customer.setPassword(dto.getPassword()); // ❗ plain text for now
        customer.setRole(UserRole.CUSTOMER);

        return customerRepository.save(customer);
    }

}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\EngineerService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.dto.EngineerRegistrationDTO;
import ticketmanagement.ticketservicemanagementv100.dto.EngineerResponseDTO;
import ticketmanagement.ticketservicemanagementv100.entity.Engineer;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class EngineerService {

    private final EngineerRepository engineerRepository;

    public EngineerResponseDTO createEngineer(EngineerRegistrationDTO dto) {
        Engineer engineer = new Engineer();
        engineer.setUsername(dto.getUsername());
        engineer.setPassword(dto.getPassword()); // TODO: hash password later
        engineer.setRole(UserRole.ENGINEER);
        Engineer saved = engineerRepository.save(engineer);
        return new EngineerResponseDTO(saved.getId(), saved.getUsername());
    }

    public List<EngineerResponseDTO> getAllEngineers() {
        return engineerRepository.findAll()
                .stream()
                .map(e -> new EngineerResponseDTO(e.getId(), e.getUsername()))
                .collect(Collectors.toList());
    }

    public Optional<EngineerResponseDTO> getEngineerById(Long id) {
        return engineerRepository.findById(id)
                .map(e -> new EngineerResponseDTO(e.getId(), e.getUsername()));
    }

    public Engineer updateEngineer(Long id, Engineer input) {
        return engineerRepository.findById(id)
                .map(engineer -> {
                    engineer.setUsername(input.getUsername());
                    engineer.setPassword(input.getPassword()); // TODO: hash password later
                    return engineerRepository.save(engineer);
                })
                .orElseThrow(() -> new EntityNotFoundException("Engineer not found with id " + id));
    }

    public void deleteEngineer(Long id) {
        if (!engineerRepository.existsById(id)) {
            throw new EntityNotFoundException("Engineer not found with id " + id);
        }
        engineerRepository.deleteById(id);
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\LoginService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.repository.CustomerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;

import java.util.Optional;

@Service
@RequiredArgsConstructor
public class LoginService {

    private final CustomerRepository customerRepository;
    private final EngineerRepository engineerRepository;

    public Optional<User> authenticate(String username, String password) {
        // First try to find in customers
        Optional<User> customer = customerRepository.findByUsername(username)
                .map(c -> (User) c)
                .filter(user -> user.getPassword().equals(password));

        if (customer.isPresent()) {
            return customer;
        }

        // If not found in customers, try engineers
        return engineerRepository.findByUsername(username)
                .map(e -> (User) e)
                .filter(user -> user.getPassword().equals(password));
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\TicketCategoryService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import ticketmanagement.ticketservicemanagementv100.entity.TicketCategory;
import ticketmanagement.ticketservicemanagementv100.repository.TicketCategoryRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TicketCategoryService {
    private final TicketCategoryRepository categoryRepository;
    
    public TicketCategory createCategory(TicketCategory category) {
        if (categoryRepository.existsByName(category.getName())) {
            throw new RuntimeException("Category name already exists");
        }
        return categoryRepository.save(category);
    }
    
    public TicketCategory updateCategory(TicketCategory category) {
        return categoryRepository.save(category);
    }
    
    public void deleteCategory(Long id) {
        categoryRepository.deleteById(id);
    }
    
    public TicketCategory findById(Long id) {
        return categoryRepository.findById(id).orElse(null);
    }
    
    public TicketCategory findByName(String name) {
        return categoryRepository.findByName(name).orElse(null);
    }
    
    public List<TicketCategory> getAllCategories() {
        return categoryRepository.findAll();
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\TicketService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.TicketRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
@RequiredArgsConstructor
public class TicketService {
    private final TicketRepository ticketRepository;
    
    public Ticket createTicket(Ticket ticket) {
        ticket.setStatus(TicketStatus.CREATED);
        ticket.setCreatedAt(LocalDateTime.now());
        ticket.setUpdatedAt(LocalDateTime.now());
        return ticketRepository.save(ticket);
    }
    
    public Ticket updateTicket(Ticket ticket) {
        ticket.setUpdatedAt(LocalDateTime.now());
        return ticketRepository.save(ticket);
    }
    
    public Ticket findById(Long id) {
        return ticketRepository.findById(id).orElse(null);
    }
    
    public List<Ticket> getTicketsForUser(User user) {
        if (user.getRole() == UserRole.CUSTOMER) {
            return ticketRepository.findByCustomer(user);
        } else {
            // For engineers, return both assigned and unassigned tickets
            List<Ticket> assignedTickets = ticketRepository.findByAssignedEngineer(user);
            List<Ticket> unassignedTickets = ticketRepository.findByAssignedEngineerIsNull();
            return Stream.concat(assignedTickets.stream(), unassignedTickets.stream())
                        .collect(Collectors.toList());
        }
    }
    
    public List<Ticket> getUnassignedTickets() {
        return ticketRepository.findByAssignedEngineerIsNull();
    }
    
    public List<Ticket> getAssignedTickets(User engineer) {
        return ticketRepository.findByAssignedEngineer(engineer);
    }
    
    public Ticket acknowledgeTicket(Long ticketId, User engineer) {
        Ticket ticket = findById(ticketId);
        if (ticket != null && ticket.getAssignedEngineer() == null) {
            ticket.setAssignedEngineer(engineer);
            ticket.setStatus(TicketStatus.ACKNOWLEDGED);
            return updateTicket(ticket);
        }
        return null;
    }
    
    public List<Ticket> searchTickets(TicketStatus status, Long categoryId, String customerName, User currentUser) {
        if (currentUser.getRole() == UserRole.CUSTOMER) {
            return ticketRepository.findCustomerTicketsWithFilters(currentUser, status, categoryId);
        } else {
            return ticketRepository.findTicketsWithFilters(status, categoryId, customerName);
        }
    }
    
    public void deleteTicket(Long id) {
        ticketRepository.deleteById(id);
    }
    
    public List<Ticket> getAllTickets() {
        return ticketRepository.findAll();
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\UserService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    
    public User authenticate(String username, String password) {
        Optional<User> optionalUser = userRepository.findByUsernameAndPassword(username, password);
        if (optionalUser.isPresent()) {
            return optionalUser.get();
        }
        return null;
    }
    
    public User findById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    
    public User findByUsername(String username) {
        return userRepository.findByUsername(username).orElse(null);
    }
    
    public List<User> findByRole(UserRole role) {
        return userRepository.findByRole(role);
    }
    
    public User findDefaultEngineer() {
        return userRepository.findByIsDefaultEngineerTrue().orElse(null);
    }
    
    public User createUser(User user) {
        if (userRepository.existsByUsername(user.getUsername())) {
            throw new RuntimeException("Username already exists");
        }
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new RuntimeException("Email already exists");
        }
        user.setCreatedAt(LocalDateTime.now());
        user.setUpdatedAt(LocalDateTime.now());
        return userRepository.save(user);
    }
    
    public User updateUser(User user) {
        user.setUpdatedAt(LocalDateTime.now());
        return userRepository.save(user);
    }
    
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
    
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    public boolean isDefaultEngineer(User user) {
        return user != null && user.getIsDefaultEngineer();
    }
}


--- File: src\main\resources\application.properties ---
spring.application.name=ticket-service-management-v100

# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/ticketdb?createDatabaseIfNotExist=true&useSSL=false&allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=root@1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true

# File Upload Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Server Configuration
server.port=8080

# Session Configuration
server.servlet.session.timeout=30m
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=false

# CORS Configuration
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.ticketmanagement.ticketservicemanagementv100=DEBUG
logging.level.org.springframework.web=DEBUG


--- File: src\test\java\ticketmanagement\ticketservicemanagementv100\TicketServiceManagementV100ApplicationTests.java ---
package ticketmanagement.ticketservicemanagementv100;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TicketServiceManagementV100ApplicationTests {

    @Test
    void contextLoads() {
    }

}


--- File: target\classes\application.properties ---
spring.application.name=ticket-service-management-v100

# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/ticketdb?createDatabaseIfNotExist=true&useSSL=false&allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=root@1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true

# File Upload Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Server Configuration
server.port=8080

# Session Configuration
server.servlet.session.timeout=30m
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=false

# CORS Configuration
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.ticketmanagement.ticketservicemanagementv100=DEBUG
logging.level.org.springframework.web=DEBUG
