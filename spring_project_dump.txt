

--- File: .mvn\wrapper\maven-wrapper.properties ---
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\TicketServiceManagementV100Application.java ---
package ticketmanagement.ticketservicemanagementv100;

import org.springframework.beans.factory.annotation.Value;
import ticketmanagement.ticketservicemanagementv100.model.Engineer;
import ticketmanagement.ticketservicemanagementv100.model.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class TicketServiceManagementV100Application {

    public static void main(String[] args) {
        SpringApplication.run(TicketServiceManagementV100Application.class, args);
    }

    /**
     * CommandLineRunner to create a default engineer on application startup if one doesn't exist.
     * This provides an "inbuilt" engineer account for initial setup and testing.
     * Note: Password is not encoded in this simplified version.
     *
     * @param engineerRepository The repository for Engineer entities.
     * @return A CommandLineRunner bean.
     */
    @Bean
    public CommandLineRunner createDefaultEngineer(EngineerRepository engineerRepository, @Value("${app.default.engineer.username}")  String defaultUsername, @Value("${app.default.engineer.password}")  String defaultPassword) {
        return args -> {
            // Check if the default engineer already exists
            if (engineerRepository.findByUsername(defaultUsername).isEmpty()) {
                Engineer defaultEngineer = new Engineer();
                defaultEngineer.setUsername(defaultUsername);
                defaultEngineer.setPassword(defaultPassword); // Password is now plain text
                defaultEngineer.setRole(UserRole.ENGINEER);
                engineerRepository.save(defaultEngineer);
                System.out.println("Default engineer '" + defaultUsername + "' created successfully!");
            } else {
                System.out.println("Default engineer '" + defaultUsername + "' already exists.");
            }
        };
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\config\CorsConfig.java ---
package ticketmanagement.ticketservicemanagementv100.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.util.Arrays;
import java.util.Collections; // Import Collections for unmodifiable lists

/**
 * Configuration class for Cross-Origin Resource Sharing (CORS).
 * CORS is a security feature that allows a web page from one domain to access a resource
 * in another domain. Without proper CORS configuration, browsers would block such requests
 * for security reasons (Same-Origin Policy).
 *
 * This configuration defines a global CORS policy for the entire application.
 */
@Configuration // Marks this class as a Spring configuration class
public class CorsConfig {

    /**
     * Defines and configures the CorsFilter bean.
     * This filter intercepts incoming requests and applies the defined CORS rules.
     *
     * @return A CorsFilter instance configured with the CORS policy.
     */
    @Bean // Marks this method as a bean definition, meaning Spring will manage its lifecycle
    public CorsFilter corsFilter() {
        // Create a new CorsConfiguration object to define the CORS policy.
        CorsConfiguration config = new CorsConfiguration();

        // 1. Allowed Origins: Specifies which origins (domains) are allowed to access resources.
        // In development, "*" is often used for convenience, allowing requests from any origin.
        // However, in production, this should be restricted to known frontend domains for security.
        // Example for production: config.setAllowedOrigins(Arrays.asList("https://yourfrontend.com", "http://localhost:3000"));
        // Using setAllowedOriginPatterns allows for more flexible patterns, including wildcards within parts of the domain.
        // For example, "http://*.yourdomain.com"
        config.setAllowedOriginPatterns(Collections.singletonList("*")); // Allows all origins (use with caution in production)

        // 2. Allowed Headers: Specifies which HTTP headers are allowed in the actual request.
        // "*" allows all headers, which is generally fine for development.
        // In a production environment, you might restrict this to only headers your application expects.
        // Example: config.setAllowedHeaders(Arrays.asList("Content-Type", "Authorization", "X-Requested-With"));
        config.setAllowedHeaders(Collections.singletonList("*")); // Allows all headers

        // 3. Allowed Methods: Specifies which HTTP methods (GET, POST, PUT, DELETE, etc.) are allowed.
        // "*" allows all standard HTTP methods.
        // Restricting this to only the methods your API supports is a good practice.
        // "OPTIONS" method is crucial for CORS preflight requests, so it should almost always be included.
        config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH")); // Allows common HTTP methods

        // 4. Allow Credentials: Indicates whether the actual request can include user credentials (like cookies,
        // HTTP authentication, or client-side SSL certificates).
        // Set to 'true' if your frontend needs to send cookies or authorization headers (e.g., JWT in Authorization header).
        // If set to true, 'allowedOriginPatterns' cannot contain '*' for security reasons;
        // you must specify explicit origins.
        config.setAllowCredentials(true);

        // 5. Exposed Headers: Specifies which headers, other than the simple response headers,
        // are exposed to the browser. By default, only a few simple headers are accessible.
        // If your backend sends custom headers that your frontend needs to read (e.g., custom error codes,
        // pagination info), you must expose them here.
        // Example: config.setExposedHeaders(Arrays.asList("X-Custom-Header", "X-Pagination-Total-Count"));
        // config.setExposedHeaders(Collections.emptyList()); // No custom headers exposed by default

        // 6. Max Age: Specifies how long the results of a preflight request (OPTIONS) can be cached.
        // The browser will cache the preflight response for this duration, reducing the number of
        // OPTIONS requests for subsequent actual requests. Value is in seconds.
        // A common value is 1 hour (3600 seconds).
        // config.setMaxAge(3600L); // Cache preflight response for 1 hour

        // Create a UrlBasedCorsConfigurationSource, which maps CORS configurations to URL patterns.
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();

        // Register the CORS configuration for all paths ("/**").
        // This means the defined 'config' will apply to all incoming requests to your application.
        source.registerCorsConfiguration("/**", config);

        // Return a new CorsFilter with the configured source.
        return new CorsFilter(source);
    }

    /**
     * Alternative/Additional approach: WebMvcConfigurer for more granular control or integration
     * with Spring MVC. This allows defining CORS rules directly within the MVC configuration.
     *
     * Uncomment and modify if you prefer this approach or need more specific path-based CORS rules.
     *
     * @Bean
     * public WebMvcConfigurer corsConfigurer() {
     * return new WebMvcConfigurer() {
     * @Override
     * public void addCorsMappings(CorsRegistry registry) {
     * registry.addMapping("/**") // Apply to all paths
     * .allowedOrigins("http://localhost:3000", "https://yourfrontend.com") // Specific origins
     * .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // Specific methods
     * .allowedHeaders("*") // All headers
     * .allowCredentials(true) // Allow credentials
     * .maxAge(3600); // Cache preflight for 1 hour
     * }
     * };
     * }
     */
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\CustomerController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import org.springframework.http.HttpStatus;
import ticketmanagement.ticketservicemanagementv100.dto.CustomerRegistrationDTO;
import ticketmanagement.ticketservicemanagementv100.dto.CustomerResponseDTO;
import ticketmanagement.ticketservicemanagementv100.model.Customer;
import ticketmanagement.ticketservicemanagementv100.service.CustomerService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/customers")
@RequiredArgsConstructor
public class CustomerController {

    private final CustomerService customerService;

    @PostMapping
    public ResponseEntity<CustomerResponseDTO> createCustomer(@RequestBody CustomerRegistrationDTO registrationDTO) {
        Customer savedCustomer = customerService.registerCustomerFromDTO(registrationDTO);
        CustomerResponseDTO customerResponseDTO = new CustomerResponseDTO(savedCustomer.getId(), savedCustomer.getUsername());
        return ResponseEntity.ok(customerResponseDTO);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Customer> updateCustomer(@PathVariable Long id, @RequestBody Customer customer) {
        try {
            Customer updatedCustomer = customerService.updateCustomer(id, customer);
            return ResponseEntity.ok(updatedCustomer);
        } catch (jakarta.persistence.EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @GetMapping
    public ResponseEntity<List<Customer>> getAllCustomers() {
        return ResponseEntity.ok(customerService.getAllCustomers());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Customer> getCustomer(@PathVariable Long id) {
        return customerService.getCustomerById((id))
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCustomer(@PathVariable Long id,
                                               @RequestHeader("X-User-Role") String role) { // Add role for restriction
        // Role restriction: Only ENGINEER role can delete
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN);
        }
        customerService.deleteCustomer(id); // This calls the method you already have in CustomerService
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\EngineerController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import org.springframework.http.HttpStatus;
import ticketmanagement.ticketservicemanagementv100.dto.EngineerRegistrationDTO;
import ticketmanagement.ticketservicemanagementv100.dto.EngineerResponseDTO;
import ticketmanagement.ticketservicemanagementv100.model.Engineer;
import ticketmanagement.ticketservicemanagementv100.service.EngineerService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/engineers")
@RequiredArgsConstructor
public class EngineerController {

    private final EngineerService engineerService;

    @PostMapping
    public ResponseEntity<EngineerResponseDTO> createEngineer(@RequestBody EngineerRegistrationDTO dto,
                                                              @RequestHeader("X-User-Role") String role) {
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build(); // 403 Forbidden
        }
        EngineerResponseDTO saved = engineerService.createEngineer(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }

    @GetMapping
    public ResponseEntity<List<EngineerResponseDTO>> getAllEngineers() {
        return ResponseEntity.ok(engineerService.getAllEngineers());
    }

    @GetMapping("/{id}")
    public ResponseEntity<EngineerResponseDTO> getEngineerById(@PathVariable Long id) {
        return engineerService.getEngineerById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{id}")
    public ResponseEntity<Engineer> updateEngineer(@PathVariable Long id, @RequestBody Engineer input) {
        try {
            Engineer updatedEngineer = engineerService.updateEngineer(id, input);
            return ResponseEntity.ok(updatedEngineer);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteEngineer(@PathVariable Long id,
                                               @RequestHeader("X-User-Role") String role) { // Add this parameter
        // Add role restriction check
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN);
        }
        engineerService.deleteEngineer(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\HomeController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HomeController {

    @GetMapping("/")
    public String home() {
        return "Welcome to the Home Page!";
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\LoginController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.dto.LoginRequest;
import ticketmanagement.ticketservicemanagementv100.dto.LoginResponseDTO;
import ticketmanagement.ticketservicemanagementv100.model.User;
import ticketmanagement.ticketservicemanagementv100.service.LoginService;

import java.util.Optional;

@RestController
@RequestMapping("/login")
@RequiredArgsConstructor
public class LoginController {

    private final LoginService loginService;

    @PostMapping
    public ResponseEntity<LoginResponseDTO> login(@RequestBody LoginRequest loginRequest) {
        Optional<User> optionalUser = loginService.authenticate(loginRequest.getUsername(), loginRequest.getPassword());

        if (optionalUser.isPresent()) {
            User user = optionalUser.get();
            LoginResponseDTO response = new LoginResponseDTO(
                    user.getUsername(),
                    user.getRole().name(),
                    "Login successful"
            );
            return ResponseEntity.ok(response);
        }

        // If authentication fails
        LoginResponseDTO errorResponse = new LoginResponseDTO(
                loginRequest.getUsername(),
                "UNKNOWN",
                "Invalid username or password"
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\TicketController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.dto.TicketCreationDTO;
import ticketmanagement.ticketservicemanagementv100.dto.TicketUpdateDTO;
import ticketmanagement.ticketservicemanagementv100.model.Customer;
import ticketmanagement.ticketservicemanagementv100.model.Engineer;
import ticketmanagement.ticketservicemanagementv100.model.Ticket;
import ticketmanagement.ticketservicemanagementv100.repository.CustomerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.TicketRepository;
import ticketmanagement.ticketservicemanagementv100.service.TicketService;
import ticketmanagement.ticketservicemanagementv100.model.TicketStatus;


import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping("/api/tickets")
@CrossOrigin(origins = "*")
@RequiredArgsConstructor
public class TicketController {

    // Remove @Autowired when using @RequiredArgsConstructor with final fields
    private final TicketService ticketService;
    private final CustomerRepository customerRepo;
    private final EngineerRepository engineerRepo;
    private final TicketRepository ticketRepo;

    /**
     * Get tickets for engineer - both assigned and unassigned tickets
     * Called by frontend: GET /api/tickets/engineer/{username}
     */
    @GetMapping("/engineer/{username}")
    public ResponseEntity<List<Ticket>> getTicketsByEngineer(
            @PathVariable String username,
            @RequestHeader("X-Username") String requestUsername,
            @RequestHeader("X-User-Role") String role) {

        // Security check: ensure engineer can only access their own assigned/unassigned tickets view
        if (!"ENGINEER".equalsIgnoreCase(role) || !username.equals(requestUsername)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            Engineer engineer = engineerRepo.findByUsername(username)
                    .orElseThrow(() -> new EntityNotFoundException("Engineer not found"));

            // Fetch tickets assigned to this engineer
            List<Ticket> assignedTickets = ticketRepo.findByAcknowledgedById(engineer.getId());

            // Fetch unassigned tickets (acknowledgedBy is null)
            List<Ticket> unassignedTickets = ticketRepo.findByAcknowledgedByIdIsNull();

            // Combine lists
            List<Ticket> combined = new ArrayList<>();
            combined.addAll(assignedTickets);
            combined.addAll(unassignedTickets);

            return ResponseEntity.ok(combined);

        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get tickets created by a specific customer (by username)
     * Called by frontend: GET /api/tickets/customer/{username}
     */
    @GetMapping("/customer/{username}")
    public ResponseEntity<List<Ticket>> getTicketsByCustomer(
            @PathVariable String username,
            @RequestHeader("X-Username") String requestUsername,
            @RequestHeader("X-User-Role") String role) {

        // Security check: ensure customer can only access their own tickets
        if (!"CUSTOMER".equalsIgnoreCase(role) || !username.equals(requestUsername)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            Customer customer = customerRepo.findByUsername(username)
                    .orElseThrow(() -> new EntityNotFoundException("Customer not found"));

            List<Ticket> tickets = ticketRepo.findByCreatedById(customer.getId());
            return ResponseEntity.ok(tickets);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Creates a new Ticket using a TicketCreationDTO.
     * This endpoint expects a DTO containing the ticket description,
     * the customerId, and an optional engineerId for immediate assignment.
     */
    @PostMapping
    public ResponseEntity<Ticket> createTicket(@RequestBody TicketCreationDTO ticketDto,
                                               @RequestHeader("X-Username") String username,
                                               @RequestHeader("X-User-Role") String role) {
        if (!"CUSTOMER".equalsIgnoreCase(role)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        if (ticketDto.getDescription() == null || ticketDto.getDescription().trim().isEmpty()) {
            return ResponseEntity.badRequest().body(null);
        }

        try {
            Customer customer = customerRepo.findByUsername(username)
                    .orElseThrow(() -> new EntityNotFoundException("Customer not found"));

            Ticket savedTicket = ticketService.createTicket(
                    customer.getId(),
                    ticketDto.getDescription(),
                    ticketDto.getEngineerId()
            );

            return new ResponseEntity<>(savedTicket, HttpStatus.CREATED);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Retrieves all Tickets.
     */
    @GetMapping
    public ResponseEntity<List<Ticket>> getAllTickets() {
        List<Ticket> tickets = ticketService.getAllTickets();
        return ResponseEntity.ok(tickets);
    }

    /**
     * Retrieves a Ticket by its ID.
     */
    @GetMapping("/{id}")
    public ResponseEntity<Ticket> getTicketById(@PathVariable Long id) {
        return ticketService.getTicketById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Updates an existing Ticket - supports comments, status, description, tentative date, reassignment
     */
    @PutMapping("/{id}")
    public ResponseEntity<Ticket> updateTicket(@PathVariable Long id,
                                               @RequestBody TicketUpdateDTO dto,
                                               @RequestHeader("X-Username") String username,
                                               @RequestHeader("X-User-Role") String role) {
        try {
            Ticket ticket = ticketService.getTicketById(id)
                    .orElseThrow(() -> new EntityNotFoundException("Ticket not found"));

            // Authorization check: customer who created or engineer assigned can update
            boolean isCustomer = "CUSTOMER".equalsIgnoreCase(role) &&
                    ticket.getCreatedBy().getUsername().equals(username);
            boolean isEngineer = "ENGINEER".equalsIgnoreCase(role) &&
                    ticket.getAcknowledgedBy() != null &&
                    ticket.getAcknowledgedBy().getUsername().equals(username);

            if (!(isCustomer || isEngineer)) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
            }

            // Customer can only update their comments
            if (dto.getCustomerCommentOnTicket() != null && isCustomer) {
                ticket.setCustomerCommentOnTicket(dto.getCustomerCommentOnTicket());
            }

            // Engineer can update multiple fields
            if (isEngineer) {
                if (dto.getEngineerCommentOnTicket() != null) {
                    ticket.setEngineerCommentOnTicket(dto.getEngineerCommentOnTicket());
                }
                if (dto.getTentativeResolutionDate() != null) {
                    ticket.setTentativeResolutionDate(dto.getTentativeResolutionDate());
                }
                if (dto.getDescription() != null) {
                    ticket.setDescription(dto.getDescription());
                }
                if (dto.getStatus() != null) {
                    ticket.setStatus(dto.getStatus());
                }
                if (dto.getEngineerId() != null) {
                    Engineer newEngineer = engineerRepo.findById(dto.getEngineerId())
                            .orElseThrow(() -> new EntityNotFoundException("Engineer not found"));
                    ticket.setAcknowledgedBy(newEngineer);
                }
            }

            Ticket updated = ticketRepo.save(ticket);
            return ResponseEntity.ok(updated);

        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Deletes a Ticket by its ID (Engineer only).
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTicket(@PathVariable Long id,
                                             @RequestHeader("X-User-Role") String role) {
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            ticketService.deleteTicket(id);
            return ResponseEntity.noContent().build();
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Engineer acknowledges ticket (assigns themselves to unassigned ticket)
     */
    @PutMapping("/{ticketId}/acknowledge")
    public ResponseEntity<Ticket> acknowledgeTicket(@PathVariable Long ticketId,
                                                    @RequestHeader("X-Username") String username,
                                                    @RequestHeader("X-User-Role") String role) {
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            Ticket ticket = ticketService.getTicketById(ticketId)
                    .orElseThrow(() -> new EntityNotFoundException("Ticket not found"));

            // Check if ticket is already assigned
            if (ticket.getAcknowledgedBy() != null) {
                return ResponseEntity.status(HttpStatus.CONFLICT).build(); // Already assigned
            }

            Engineer engineer = engineerRepo.findByUsername(username)
                    .orElseThrow(() -> new EntityNotFoundException("Engineer not found"));

            ticket.setAcknowledgedBy(engineer);
            ticket.setStatus(TicketStatus.ACKNOWLEDGED);

            Ticket updatedTicket = ticketRepo.save(ticket);
            return ResponseEntity.ok(updatedTicket);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\CustomerRegistrationDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Data Transfer Object (DTO) for registering a new Customer.
 * This DTO is used when an Engineer creates a new Customer account.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CustomerRegistrationDTO{
        private String username;
        private String password;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\CustomerResponseDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class CustomerResponseDTO {
    private Long id;
    private String username;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\EngineerRegistrationDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO for creating a new Engineer.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class EngineerRegistrationDTO {
    private String username;
    private String password;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\EngineerResponseDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class EngineerResponseDTO {
    private Long id;
    private String username;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\LoginRequest.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Data Transfer Object (DTO) for user login requests.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    private String username;
    private String password;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\LoginResponseDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO for login responses.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponseDTO {
    private String username;
    private String role;
    private String message;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\TicketCreationDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
/*
 * Data Transfer Object (DTO) for creating a new Ticket.
 * This class defines the minimal set of information required from the client
 * to create a ticket. The customerId will now be explicitly provided.
 * It still includes an optional engineerId for immediate assignment.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class TicketCreationDTO {
    private String description;
   // private Long customerId; // Uncommented to allow direct passing of customerId
    private Long engineerId;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\TicketUpdateDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import ticketmanagement.ticketservicemanagementv100.model.TicketStatus;

import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class TicketUpdateDTO {
    private String description;
    private TicketStatus status;
    private String customerCommentOnTicket;
    private String engineerCommentOnTicket;
    private LocalDate tentativeResolutionDate;
    private Long engineerId; // Optional reassignment
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\model\Customer.java ---
package ticketmanagement.ticketservicemanagementv100.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Getter
@Setter
@Table(name = "customers")
@NoArgsConstructor
public class Customer extends User {
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\model\Engineer.java ---
package ticketmanagement.ticketservicemanagementv100.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;


@Getter
@Setter
@NoArgsConstructor
@Entity
@Table(name = "engineers")
public class Engineer extends User {
    public Engineer(Long id, String username, String password) {
        super(id, username, password);
    }

}



--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\model\Ticket.java ---
package ticketmanagement.ticketservicemanagementv100.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;


@Entity
@Table(name = "tickets")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String description;
    private LocalDateTime ticketCreateDate;
    private String customerCommentOnTicket;
    private String engineerCommentOnTicket;
    private LocalDate tentativeResolutionDate;

    @Enumerated(EnumType.STRING)
    private TicketStatus status = TicketStatus.CREATED;

    @ManyToOne(optional = false)
    @JoinColumn(name = "customer_id", nullable = false)
    private Customer createdBy;

    @ManyToOne(optional = true)
    @JoinColumn(name = "engineer_id")
    private Engineer acknowledgedBy;

    @PrePersist
    public void prePersist() {
        this.ticketCreateDate = LocalDateTime.now();
    }

}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\model\TicketStatus.java ---
package ticketmanagement.ticketservicemanagementv100.model;

public enum TicketStatus {
    CREATED,
    ACKNOWLEDGED,
    IN_PROGRESS,
    CLOSED
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\model\User.java ---
package ticketmanagement.ticketservicemanagementv100.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;


@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@MappedSuperclass
public abstract class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Use IDENTITY for auto-incrementing IDs
    private Long id;

    @Column(unique = true, nullable = false) // Username must be unique and not null
    private String username;

    @Column(nullable = false) // Password must not be null
    private String password;

    @Enumerated(EnumType.STRING) // Store enum as String in DB
    @Column(nullable = false) // Role must not be null
    private UserRole role; // New field for user roles

    public User(Long id, String username, String password) {
        this.id = id;
        this.username = username;
        this.password = password;
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\model\UserRole.java ---
package ticketmanagement.ticketservicemanagementv100.model;

/**
 * Enum to define user roles within the application.
 */
public enum UserRole {
    CUSTOMER,
    ENGINEER
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\CustomerRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ticketmanagement.ticketservicemanagementv100.model.Customer;

import java.util.Optional;

public interface CustomerRepository extends JpaRepository<Customer, Long> {
    Optional<Customer> findByUsername(String username);
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\EngineerRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ticketmanagement.ticketservicemanagementv100.model.Engineer;

import java.util.Optional;

public interface EngineerRepository extends JpaRepository<Engineer, Long> {
    Optional<Engineer> findByUsername(String username); // New method for finding engineer by username
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\TicketRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;


import org.springframework.data.jpa.repository.JpaRepository;
import ticketmanagement.ticketservicemanagementv100.model.Ticket;
import ticketmanagement.ticketservicemanagementv100.model.TicketStatus;

import java.util.List;


public interface TicketRepository extends JpaRepository<Ticket, Long> {
    // TicketRepository.java
    List<Ticket> findByCreatedById(Long customerId);

    List<Ticket> findByAcknowledgedById(Long engineerId);

    List<Ticket> findByStatus(TicketStatus status);

    List<Ticket> findByAcknowledgedByIdIsNull();

}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\CustomerService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.dto.CustomerRegistrationDTO;
import ticketmanagement.ticketservicemanagementv100.model.Customer;
import ticketmanagement.ticketservicemanagementv100.model.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.CustomerRepository;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class CustomerService {

    private final CustomerRepository customerRepository;

    /**
     * Retrieves all Customers.
     *
     * @return A list of all Customer objects.
     */
    public List<Customer> getAllCustomers() {
        return customerRepository.findAll();
    }

    /**
     * Retrieves a Customer by their ID.
     *
     * @param id The ID of the customer to retrieve.
     * @return An Optional containing the Customer if found, or empty if not.
     */
    public Optional<Customer> getCustomerById(Long id) {
        return customerRepository.findById(id);
    }

    /**
     * Updates an existing Customer.
     *
     * @param id The ID of the customer to update.
     * @param customerDetails The Customer object containing updated details.
     * @return The updated Customer object.
     * @throws EntityNotFoundException if no customer with the given ID is found.
     */
    public Customer updateCustomer(Long id, Customer customerDetails) {
        return customerRepository.findById(id)
                .map(customer -> {
                    customer.setUsername(customerDetails.getUsername());
                    customer.setPassword(customerDetails.getPassword());
                    return customerRepository.save(customer);
                })
                .orElseThrow(() -> new EntityNotFoundException("Customer not found with id " + id));
    }

    /**
     * Deletes a Customer by their ID.
     *
     * @param id The ID of the customer to delete.
     * @throws EntityNotFoundException if no customer with the given ID is found.
     */
    public void deleteCustomer(Long id) {
        if (!customerRepository.existsById(id)) {
            throw new EntityNotFoundException("Customer not found with id " + id);
        }
        customerRepository.deleteById(id);
    }

    public Customer registerCustomerFromDTO(CustomerRegistrationDTO dto) {
        if (dto.getUsername() == null || dto.getPassword() == null ||
                dto.getUsername().isBlank() || dto.getPassword().isBlank()) {
            throw new IllegalArgumentException("Username and password must not be blank.");
        }

        Customer customer = new Customer();
        customer.setUsername(dto.getUsername());
        customer.setPassword(dto.getPassword()); // ‚ùó plain text for now
        customer.setRole(UserRole.CUSTOMER);

        return customerRepository.save(customer);
    }

}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\EngineerService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.dto.EngineerRegistrationDTO;
import ticketmanagement.ticketservicemanagementv100.dto.EngineerResponseDTO;
import ticketmanagement.ticketservicemanagementv100.model.Engineer;
import ticketmanagement.ticketservicemanagementv100.model.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class EngineerService {

    private final EngineerRepository engineerRepository;

    public EngineerResponseDTO createEngineer(EngineerRegistrationDTO dto) {
        Engineer engineer = new Engineer();
        engineer.setUsername(dto.getUsername());
        engineer.setPassword(dto.getPassword()); // TODO: hash password later
        engineer.setRole(UserRole.ENGINEER);
        Engineer saved = engineerRepository.save(engineer);
        return new EngineerResponseDTO(saved.getId(), saved.getUsername());
    }

    public List<EngineerResponseDTO> getAllEngineers() {
        return engineerRepository.findAll()
                .stream()
                .map(e -> new EngineerResponseDTO(e.getId(), e.getUsername()))
                .collect(Collectors.toList());
    }

    public Optional<EngineerResponseDTO> getEngineerById(Long id) {
        return engineerRepository.findById(id)
                .map(e -> new EngineerResponseDTO(e.getId(), e.getUsername()));
    }

    public Engineer updateEngineer(Long id, Engineer input) {
        return engineerRepository.findById(id)
                .map(engineer -> {
                    engineer.setUsername(input.getUsername());
                    engineer.setPassword(input.getPassword()); // TODO: hash password later
                    return engineerRepository.save(engineer);
                })
                .orElseThrow(() -> new EntityNotFoundException("Engineer not found with id " + id));
    }

    public void deleteEngineer(Long id) {
        if (!engineerRepository.existsById(id)) {
            throw new EntityNotFoundException("Engineer not found with id " + id);
        }
        engineerRepository.deleteById(id);
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\LoginService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.model.User;
import ticketmanagement.ticketservicemanagementv100.repository.CustomerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;

import java.util.Optional;

@Service
@RequiredArgsConstructor
public class LoginService {

    private final CustomerRepository customerRepository;
    private final EngineerRepository engineerRepository;

    public Optional<User> authenticate(String username, String password) {
        // First try to find in customers
        Optional<User> customer = customerRepository.findByUsername(username)
                .map(c -> (User) c)
                .filter(user -> user.getPassword().equals(password));

        if (customer.isPresent()) {
            return customer;
        }

        // If not found in customers, try engineers
        return engineerRepository.findByUsername(username)
                .map(e -> (User) e)
                .filter(user -> user.getPassword().equals(password));
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\TicketService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import ticketmanagement.ticketservicemanagementv100.model.Customer;
import ticketmanagement.ticketservicemanagementv100.model.Engineer;
import ticketmanagement.ticketservicemanagementv100.model.Ticket;
import ticketmanagement.ticketservicemanagementv100.model.TicketStatus;
import ticketmanagement.ticketservicemanagementv100.repository.CustomerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.TicketRepository;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

/**
 * Service class for managing Ticket entities.
 * This class encapsulates the business logic for creating, acknowledging,
 * updating, retrieving, and deleting tickets.
 */
@Service
@RequiredArgsConstructor // Using Lombok's RequiredArgsConstructor for constructor injection
public class TicketService {

    private final TicketRepository ticketRepo;
    private final CustomerRepository customerRepo;
    private final EngineerRepository engineerRepo;

    /**
     * Creates a new ticket.
     * The customer creating the ticket is identified by their ID.
     *
     * @param customerId  The ID of the customer creating the ticket.
     * @param description The description of the ticket.
     * @param engineerId  An optional ID of the engineer to immediately acknowledge the ticket.
     * @return The newly created Ticket object.
     * @throws EntityNotFoundException if the customer or specified engineer is not found.
     */
    public Ticket createTicket(Long customerId, String description, Long engineerId) {
        // Find the customer by ID, throwing an exception if not found
        Customer customer = customerRepo.findById(customerId)
                .orElseThrow(() -> new EntityNotFoundException("Customer not found with id " + customerId));

        // Create a new Ticket instance
        Ticket ticket = new Ticket();
        ticket.setCreatedBy(customer); // Set the customer who created the ticket
        ticket.setDescription(description); // Set the ticket description

        // If an engineer ID is provided, assign the engineer and set status to ACKNOWLEDGED
        if (engineerId != null) {
            Engineer engineer = engineerRepo.findById(engineerId)
                    .orElseThrow(() -> new EntityNotFoundException("Engineer not found with id " + engineerId));
            ticket.setAcknowledgedBy(engineer);
            ticket.setStatus(TicketStatus.ACKNOWLEDGED); // Set status to ACKNOWLEDGED if assigned
        } else {
            // If no engineer is assigned, set status to CREATED
            ticket.setStatus(TicketStatus.CREATED);
        }

        // Save the new ticket to the repository
        return ticketRepo.save(ticket);
    }

    /**
     * Acknowledges a ticket by assigning the engineer identified by their username
     * and updating its status.
     *
     * @param ticketId The ID of the ticket to acknowledge.
     * @param engineerUsername The username of the engineer acknowledging the ticket.
     * @return The updated Ticket object.
     * @throws EntityNotFoundException if the ticket or engineer is not found.
     */
    public Ticket acknowledgeTicket(Long ticketId, String engineerUsername) {
        // Find the ticket by ID, throwing an exception if not found
        Ticket ticket = ticketRepo.findById(ticketId)
                .orElseThrow(() -> new EntityNotFoundException("Ticket not found with id " + ticketId));

        // Find the engineer by username, throwing an exception if not found
        Engineer engineer = engineerRepo.findByUsername(engineerUsername)
                .orElseThrow(() -> new EntityNotFoundException("Engineer not found with username " + engineerUsername));

        // Update the ticket status and assigned engineer
        ticket.setStatus(TicketStatus.ACKNOWLEDGED);
        ticket.setAcknowledgedBy(engineer);

        // Save the updated ticket
        return ticketRepo.save(ticket);
    }

    /**
     * Retrieves all tickets.
     *
     * @return A list of all Ticket objects.
     */
    public List<Ticket> getAllTickets() {
        return ticketRepo.findAll();
    }

    /**
     * Retrieves a ticket by its ID.
     *
     * @param id The ID of the ticket to retrieve.
     * @return An Optional containing the Ticket if found, or empty if not.
     */
    public Optional<Ticket> getTicketById(Long id) {
        return ticketRepo.findById(id);
    }

    /**
     * Updates an existing ticket.
     *
     * @param id            The ID of the ticket to update.
     * @param ticketDetails The Ticket object containing updated details.
     * @return The updated Ticket object.
     * @throws EntityNotFoundException if no ticket with the given ID is found.
     */
    public Ticket updateTicket(Long id, Ticket ticketDetails) {
        return ticketRepo.findById(id)
                .map(ticket -> {
                    ticket.setDescription(ticketDetails.getDescription());
                    ticket.setStatus(ticketDetails.getStatus());
                    ticket.setTentativeResolutionDate(ticketDetails.getTentativeResolutionDate());
                    ticket.setCustomerCommentOnTicket(ticketDetails.getCustomerCommentOnTicket());
                    ticket.setEngineerCommentOnTicket(ticketDetails.getEngineerCommentOnTicket());

                    if (ticketDetails.getAcknowledgedBy() != null) {
                        ticket.setAcknowledgedBy(ticketDetails.getAcknowledgedBy());
                    }

                    return ticketRepo.save(ticket);
                })
                .orElseThrow(() -> new EntityNotFoundException("Ticket not found with id " + id));
    }


    /**
     * Deletes a ticket by its ID.
     *
     * @param id The ID of the ticket to delete.
     * @throws EntityNotFoundException if no ticket with the given ID is found.
     */
    public void deleteTicket(Long id) {
        // Check if the ticket exists before attempting to delete
        if (!ticketRepo.existsById(id)) {
            throw new EntityNotFoundException("Ticket not found with id " + id);
        }
        ticketRepo.deleteById(id); // Delete the ticket
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\UserService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.model.User;
import ticketmanagement.ticketservicemanagementv100.repository.CustomerRepository;
import ticketmanagement.ticketservicemanagementv100.repository.EngineerRepository;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Service
public class UserService {

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private EngineerRepository engineerRepository;

    public List<User> getAllUsers() {
        List<User> allUsers = new ArrayList<>();
        allUsers.addAll(customerRepository.findAll());
        allUsers.addAll(engineerRepository.findAll());
        return allUsers;
    }

    public Optional<User> getUserById(Long id) {
        // Try to find in customers first
        Optional<User> customer = customerRepository.findById(id).map(c -> (User) c);
        if (customer.isPresent()) {
            return customer;
        }

        // If not found in customers, try engineers
        return engineerRepository.findById(id).map(e -> (User) e);
    }

    // Note: createUser method removed as you should use CustomerService or EngineerService
    // to create specific user types with proper roles

    // Note: updateUser method removed as you should use CustomerService or EngineerService
    // to update specific user types

    // Note: deleteUser method removed as you should use CustomerService or EngineerService
    // to delete specific user types

    public Optional<User> findByUsername(String username) {
        // First try to find in customers
        Optional<User> customer = customerRepository.findByUsername(username)
                .map(c -> (User) c);

        if (customer.isPresent()) {
            return customer;
        }

        // If not found in customers, try engineers
        return engineerRepository.findByUsername(username)
                .map(e -> (User) e);
    }
}

--- File: src\main\resources\application.properties ---
spring.application.name=TicketServiceManagementV100

# DataSource Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/ticketdb
spring.datasource.username=root
spring.datasource.password=root@1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Server Port
server.port=9090

# Optional: Logging
#debug=true

# For production, change DEBUG to INFO or WARN for less verbose logging
logging.level.org.hibernate.SQL=INFO

# Removed security-related properties


# CORS Configuration (Additional safety)
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Username & Password
app.default.engineer.username=default_engineer
app.default.engineer.password=password

--- File: src\test\java\ticketmanagement\ticketservicemanagementv100\TicketServiceManagementV100ApplicationTests.java ---
package ticketmanagement.ticketservicemanagementv100;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TicketServiceManagementV100ApplicationTests {

    @Test
    void contextLoads() {
    }

}


--- File: target\classes\application.properties ---
spring.application.name=TicketServiceManagementV100

# DataSource Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/ticketdb
spring.datasource.username=root
spring.datasource.password=root@1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Server Port
server.port=9090

# Optional: Logging
#debug=true

# For production, change DEBUG to INFO or WARN for less verbose logging
logging.level.org.hibernate.SQL=INFO

# Removed security-related properties


# CORS Configuration (Additional safety)
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Username & Password
app.default.engineer.username=default_engineer
app.default.engineer.password=password