<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.3</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>ticket-management</groupId>
    <artifactId>TicketServiceManagementV100</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>TicketServiceManagementV100</name>
    <description>TicketServiceManagementV100</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>21</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>

                </configuration>
            </plugin>
        </plugins>
    </build>

</project>


--- File: .mvn\wrapper\maven-wrapper.properties ---
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\TicketServiceManagementV100Application.java ---
package ticketmanagement.ticketservicemanagementv100;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TicketServiceManagementV100Application {
    public static void main(String[] args) {
        SpringApplication.run(TicketServiceManagementV100Application.class, args);
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\config\CorsConfig.java ---
package ticketmanagement.ticketservicemanagementv100.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;

@Configuration
public class CorsConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(false);
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(Arrays.asList("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\AdminController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.entity.TicketCategory;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.service.TicketCategoryService;
import ticketmanagement.ticketservicemanagementv100.service.UserService;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class AdminController {
    private final UserService userService;
    private final TicketCategoryService categoryService;

    @PostMapping("/customers")
    public ResponseEntity<Map<String, Object>> createCustomer(@RequestBody User customer, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            customer.setRole(UserRole.CUSTOMER);
            customer.setIsDefaultEngineer(false);

            User createdCustomer = userService.createUser(customer);
            response.put("success", true);
            response.put("customer", createdCustomer);
            response.put("message", "Customer created successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (RuntimeException e) {
            response.put("success", false);
            response.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @PostMapping("/engineers")
    public ResponseEntity<Map<String, Object>> createEngineer(@RequestBody User engineer, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            engineer.setRole(UserRole.ENGINEER);
            engineer.setIsDefaultEngineer(false);

            User createdEngineer = userService.createUser(engineer);
            response.put("success", true);
            response.put("engineer", createdEngineer);
            response.put("message", "Engineer created successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (RuntimeException e) {
            response.put("success", false);
            response.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/customers")
    public ResponseEntity<Map<String, Object>> getAllCustomers(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            List<User> customers = userService.findByRole(UserRole.CUSTOMER);
            response.put("success", true);
            response.put("customers", customers);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching customers: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PostMapping("/categories")
    public ResponseEntity<Map<String, Object>> createCategory(@RequestBody TicketCategory category, HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            TicketCategory createdCategory = categoryService.createCategory(category);
            response.put("success", true);
            response.put("category", createdCategory);
            response.put("message", "Category created successfully");
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (RuntimeException e) {
            response.put("success", false);
            response.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(response);
        }
    }

    @GetMapping("/categories")
    public ResponseEntity<Map<String, Object>> getAllCategories(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser == null || !userService.isDefaultEngineer(currentUser)) {
            response.put("success", false);
            response.put("message", "Access denied");
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
        }

        try {
            List<TicketCategory> categories = categoryService.getAllCategories();
            response.put("success", true);
            response.put("categories", categories);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Error fetching categories: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\AuthController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.service.UserService;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@CrossOrigin(origins = "*")
public class AuthController {
    private final UserService userService;

    @PostMapping("/login")
    public ResponseEntity<Map<String, Object>> login(@RequestBody Map<String, String> credentials, HttpSession session) {
        Map<String, Object> response = new HashMap<>();

        try {
            String username = credentials.get("username");
            String password = credentials.get("password");

            User user = userService.authenticate(username, password);
            if (user != null) {
                session.setAttribute("currentUser", user);
                response.put("success", true);
                response.put("user", user);
                response.put("role", user.getRole().toString());
                response.put("message", "Login successful");
                return ResponseEntity.ok(response);
            }

            response.put("success", false);
            response.put("message", "Invalid credentials");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);

        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Login failed: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PostMapping("/logout")
    public ResponseEntity<Map<String, Object>> logout(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        try {
            session.invalidate();
            response.put("success", true);
            response.put("message", "Logout successful");
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("success", false);
            response.put("message", "Logout failed");
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @GetMapping("/current-user")
    public ResponseEntity<Map<String, Object>> getCurrentUser(HttpSession session) {
        Map<String, Object> response = new HashMap<>();
        User currentUser = (User) session.getAttribute("currentUser");

        if (currentUser != null) {
            response.put("success", true);
            response.put("user", currentUser);
            return ResponseEntity.ok(response);
        }

        response.put("success", false);
        response.put("message", "No user logged in");
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\HomeController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HomeController {

    @GetMapping("/")
    public String home() {
        return "Welcome to the Home Page!";
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\controller\TicketController.java ---
package ticketmanagement.ticketservicemanagementv100.controller;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ticketmanagement.ticketservicemanagementv100.dto.TicketCreationDTO;
import ticketmanagement.ticketservicemanagementv100.dto.TicketUpdateDTO;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.repository.TicketRepository;
import ticketmanagement.ticketservicemanagementv100.service.TicketService;
import ticketmanagement.ticketservicemanagementv100.service.UserService;

import java.util.List;

/**
 * REST Controller for managing Ticket resources.
 * This controller handles HTTP requests related to tickets,
 * delegating business logic to the TicketService.
 * <p>
 * Updated: Changed base request mapping to "/api/tickets" to match frontend.
 */
@RestController
@RequestMapping("/api/tickets") // Changed to /api/tickets
@RequiredArgsConstructor
public class TicketController {

    private final TicketService ticketService; // Inject the service
  //  private final TicketRepository ticketRepo;
    private final UserService userService;

    /**
     * Creates a new Ticket using a TicketCreationDTO.
     * This endpoint expects a DTO containing the ticket description,
     * the customerId, and an optional engineerId for immediate assignment.
     *
     * @param ticketDto The TicketCreationDTO object containing description, customerId, and optional engineerId.
     * @param username  The username of the customer creating the ticket (from X-Username header).
     * @param role      The role of the user (from X-User-Role header).
     * @return ResponseEntity containing the created Ticket and HTTP status 201 (Created).
     */
    @PostMapping
    public ResponseEntity<Ticket> createTicket(@RequestBody TicketCreationDTO ticketDto,
                                               @RequestHeader("X-Username") String username,
                                               @RequestHeader("X-User-Role") String role) {
        if (!"CUSTOMER".equalsIgnoreCase(role)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        if (ticketDto.getDescription() == null || ticketDto.getDescription().trim().isEmpty()) {
            return ResponseEntity.badRequest().body(null);
        }

        User customer = userService.findByUsername(username);
        if (customer == null) {
            throw new EntityNotFoundException("Customer not found");
        }

        Ticket savedTicket = ticketService.createTicket(
                customer.getId(),
                ticketDto.getDescription(),
                ticketDto.getEngineerId()
        );

        return new ResponseEntity<>(savedTicket, HttpStatus.CREATED);
    }


    /**
     * Retrieves all Tickets.
     *
     * @return ResponseEntity containing a list of all Tickets and HTTP status 200 (OK).
     */
    @GetMapping
    public ResponseEntity<List<Ticket>> getAllTickets() {
        List<Ticket> tickets = ticketService.getAllTickets();
        return ResponseEntity.ok(tickets);
    }

    /**
     * Retrieves a Ticket by its ID.
     *
     * @param id The ID of the ticket to retrieve.
     * @return ResponseEntity containing the Ticket if found (HTTP 200 OK),
     * or HTTP status 404 (Not Found) if not found.
     */
    @GetMapping("/{id}")
    public ResponseEntity<Ticket> getTicketById(@PathVariable Long id) {
        return ticketService.getTicketById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Updates an existing Ticket.
     *
     * @param id  The ID of the ticket to update.
     * @param dto The Ticket object with updated details.
     * @return ResponseEntity containing the updated Ticket (HTTP 200 OK),
     * or HTTP status 404 (Not Found) if the ticket does not exist.
     */
    @PutMapping("/{id}")
    public ResponseEntity<Ticket> updateTicket(@PathVariable Long id,
                                               @RequestBody TicketUpdateDTO dto) {
        try {
            Ticket ticket = ticketService.getTicketById(id)
                    .orElseThrow(() -> new EntityNotFoundException("Ticket not found"));

            if (dto.getEngineerId() != null) {
                User engineer = userService.findById(dto.getEngineerId());
                if (engineer == null) {
                    throw new EntityNotFoundException("Engineer not found");
                }
                ticket.setAssignedEngineer(engineer);
            }

            ticket.setDescription(dto.getDescription());
            ticket.setStatus(dto.getStatus());
            ticket.setTentativeResolutionDate(dto.getTentativeResolutionDate());

            Ticket updated = ticketService.updateTicket(ticket);
            return ResponseEntity.ok(updated);

        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }


    /**
     * Deletes a Ticket by its ID.
     *
     * @param id   The ID of the ticket to delete.
     * @param role The role of the user (from X-User-Role header).
     * @return ResponseEntity with HTTP status 200 (OK) if deleted successfully,
     * or HTTP status 404 (Not Found) if the ticket does not exist.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTicket(@PathVariable Long id,
                                             @RequestHeader("X-User-Role") String role) {
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return new ResponseEntity<>(HttpStatus.FORBIDDEN);
        }
        ticketService.deleteTicket(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    /**
     * Acknowledges a ticket by assigning the currently logged-in engineer.
     * The engineer's username is retrieved from the X-Username header.
     *
     * @param ticketId         The ID of the ticket to acknowledge.
     * @param engineerUsername The username of the engineer acknowledging the ticket (from X-Username header).
     * @return ResponseEntity containing the acknowledged Ticket (HTTP 200 OK),
     * or HTTP status 404 (Not Found) if ticket or engineer does not exist.
     * @return ResponseEntity with HTTP status 403 (Forbidden) if the user is not an ENGINEER.
     */
    @PutMapping("/{ticketId}/acknowledge") // Modified endpoint: removed {engineerId} from path
    public ResponseEntity<Ticket> acknowledgeTicket(
            @PathVariable Long ticketId,
            @RequestHeader("X-Username") String engineerUsername, // Get username from header
            @RequestHeader("X-User-Role") String role) { // Get role from header for validation
        if (!"ENGINEER".equalsIgnoreCase(role)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }
        try {
            // Call service method with username
            Ticket acknowledgedTicket = ticketService.acknowledgeTicket(ticketId, engineerUsername);
            return ResponseEntity.ok(acknowledgedTicket);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get tickets created by a specific customer (by username)
     * Called by frontend: GET /api/tickets/customer/{username}
     */
    @GetMapping("/customer/{username}")
    public ResponseEntity<List<Ticket>> getTicketsByCustomer(
            @PathVariable String username,
            @RequestHeader("X-Username") String requestUsername,
            @RequestHeader("X-User-Role") String role) {

        // Security check: ensure customer can only access their own tickets
        if (!"CUSTOMER".equalsIgnoreCase(role) || !username.equals(requestUsername)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            Customer customer = customerRepo.findByUsername(username)
                    .orElseThrow(() -> new EntityNotFoundException("Customer not found"));

            List<Ticket> tickets = ticketRepo.findByCreatedById(customer.getId());
            return ResponseEntity.ok(tickets);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Get tickets assigned to a specific engineer (by username)
     * Called by frontend: GET /api/tickets/engineer/{username}
     */
    @GetMapping("/engineer/{username}")
    public ResponseEntity<List<Ticket>> getTicketsByEngineer(
            @PathVariable String username,
            @RequestHeader("X-Username") String requestUsername,
            @RequestHeader("X-User-Role") String role) {

        // Security check: ensure engineer can only access their own assigned tickets
        if (!"ENGINEER".equalsIgnoreCase(role) || !username.equals(requestUsername)) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
        }

        try {
            Engineer engineer = engineerRepo.findByUsername(username)
                    .orElseThrow(() -> new EntityNotFoundException("Engineer not found"));

            List<Ticket> tickets = ticketRepo.findByAcknowledgedById(engineer.getId());
            return ResponseEntity.ok(tickets);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\CategoryDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CategoryDTO {

    private String name;
    private String description;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\LoginResponseDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO for login responses.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponseDTO {
    private String username;
    private String role;
    private String message;
    private boolean success;
    private Long id;
    private String fullName;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\TicketCreationDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
/*
 * Data Transfer Object (DTO) for creating a new Ticket.
 * This class defines the minimal set of information required from the client
 * to create a ticket. The customerId will now be explicitly provided.
 * It still includes an optional engineerId for immediate assignment.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class TicketCreationDTO {
    private String description;
   // private Long customerId; // Uncommented to allow direct passing of customerId
    private Long engineerId;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\dto\TicketUpdateDTO.java ---
package ticketmanagement.ticketservicemanagementv100.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;

import java.time.LocalDate;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class TicketUpdateDTO {
    private String description;
    private TicketStatus status;
    private Long categoryId;
    private Long engineerId;
    private LocalDate tentativeResolutionDate;
    private String customerCommentOnTicket;
    private String engineerCommentOnTicket;
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\Attachment.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "attachments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Attachment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String fileName;

    @Column(nullable = false)
    private String filePath;

    private String fileType;

    private Long fileSize;

    private String comment;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ticket_id", nullable = false)
    @JsonIgnoreProperties({"comments", "attachments", "customer", "assignedEngineer"})
    private Ticket ticket;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "uploaded_by", nullable = false)
    @JsonIgnoreProperties({"createdTickets", "assignedTickets"})
    private User uploadedBy;

    @Column(nullable = false)
    private LocalDateTime uploadedAt = LocalDateTime.now();
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\Comment.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Entity
@Table(name = "comments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Comment {  // ✅ Make sure class name matches filename
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ticket_id", nullable = false)
    @JsonIgnoreProperties({"comments", "attachments", "customer", "assignedEngineer"})
    private Ticket ticket;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "author_id", nullable = false)
    @JsonIgnoreProperties({"createdTickets", "assignedTickets"})
    private User author;

    @Column(nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\Ticket.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;
import ticketmanagement.ticketservicemanagementv100.entity.TicketCategory;

import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "tickets")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private TicketStatus status = TicketStatus.CREATED;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "customer_id", nullable = false)
    @JsonIgnoreProperties({"createdTickets", "assignedTickets"})
    private User customer;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "assigned_engineer_id")
    @JsonIgnoreProperties({"createdTickets", "assignedTickets"})
    private User assignedEngineer;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "category_id")
    private TicketCategory category;

    private LocalDateTime tentativeResolutionDate;

    @Column(nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(nullable = false)
    private LocalDateTime updatedAt = LocalDateTime.now();

    @OneToMany(mappedBy = "ticket", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Comment> comments;

    @OneToMany(mappedBy = "ticket", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Attachment> attachments;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\TicketCategory.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Entity
@Table(name = "ticket_categories")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TicketCategory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name;

    private String description;

    @OneToMany(mappedBy = "category", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private List<Ticket> tickets;
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\entity\User.java ---
package ticketmanagement.ticketservicemanagementv100.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String fullName;

    @Column(nullable = false)
    private String email;

    // ADD THESE MISSING FIELDS:
    private String phoneNumber;                    // ✅ ADD
    private String address;                        // ✅ ADD (for customers)
    private String specialization;                 // ✅ ADD (for engineers)
    private Boolean isDefaultEngineer = false;     // ✅ ADD

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserRole role;

    @Column(nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    @Column(nullable = false)
    private LocalDateTime updatedAt = LocalDateTime.now();

    // ADD THESE RELATIONSHIPS:
    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private List<Ticket> createdTickets = new ArrayList<>();    // ✅ ADD

    @OneToMany(mappedBy = "assignedEngineer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private List<Ticket> assignedTickets = new ArrayList<>();   // ✅ ADD
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\enums\TicketStatus.java ---
package ticketmanagement.ticketservicemanagementv100.enums;

public enum TicketStatus {
    CREATED, ACKNOWLEDGED, IN_PROGRESS, CLOSED
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\enums\UserRole.java ---
package ticketmanagement.ticketservicemanagementv100.enums;

public enum UserRole {
    CUSTOMER, ENGINEER
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\AttachmentRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import ticketmanagement.ticketservicemanagementv100.entity.Attachment;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AttachmentRepository extends JpaRepository<Attachment, Long> {
    List<Attachment> findByTicket(Ticket ticket);
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\CommentRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import ticketmanagement.ticketservicemanagementv100.entity.Comment;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByTicketOrderByCreatedAtAsc(Ticket ticket);
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\TicketCategoryRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import ticketmanagement.ticketservicemanagementv100.entity.TicketCategory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface TicketCategoryRepository extends JpaRepository<TicketCategory, Long> {
    Optional<TicketCategory> findByName(String name);
    boolean existsByName(String name);
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\TicketRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;

import java.util.List;

@Repository
public interface TicketRepository extends JpaRepository<Ticket, Long> {

    List<Ticket> findByCustomer(User customer);

    List<Ticket> findByAssignedEngineer(User engineer);

    List<Ticket> findByAssignedEngineerIsNull();

    List<Ticket> findByStatus(TicketStatus status);

    List<Ticket> findByCategoryId(Long categoryId);

    // ADD THESE MISSING METHODS:
    @Query("SELECT t FROM Ticket t WHERE t.customer = :user AND " +
            "(:status IS NULL OR t.status = :status) AND " +
            "(:categoryId IS NULL OR t.category.id = :categoryId)")
    List<Ticket> findCustomerTicketsWithFilters(@Param("user") User user,
                                                @Param("status") TicketStatus status,
                                                @Param("categoryId") Long categoryId);   // ✅ ADD

    @Query("SELECT t FROM Ticket t WHERE " +
            "(:status IS NULL OR t.status = :status) AND " +
            "(:categoryId IS NULL OR t.category.id = :categoryId) AND " +
            "(:customerName IS NULL OR LOWER(t.customer.fullName) LIKE LOWER(CONCAT('%', :customerName, '%')))")
    List<Ticket> findTicketsWithFilters(@Param("status") TicketStatus status,
                                        @Param("categoryId") Long categoryId,
                                        @Param("customerName") String customerName);   // ✅ ADD

    // ADD CONVENIENCE METHODS:
    List<Ticket> findByCreatedById(Long customerId);        // ✅ ADD

    List<Ticket> findByAcknowledgedById(Long engineerId);   // ✅ ADD
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\repository\UserRepository.java ---
package ticketmanagement.ticketservicemanagementv100.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);

    Optional<User> findByUsernameAndPassword(String username, String password);

    List<User> findByRole(UserRole role);

    Optional<User> findByIsDefaultEngineerTrue();

    boolean existsByUsername(String username);

    boolean existsByEmail(String email);

    List<User> findByIsDefaultEngineerFalse();              // ✅ ADD

    Optional<User> findByEmail(String email);               // ✅ ADD
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\AttachmentService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import ticketmanagement.ticketservicemanagementv100.entity.Attachment;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.repository.AttachmentRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class AttachmentService {
    private final AttachmentRepository attachmentRepository;
    private final String uploadDir = "uploads/";
    
    public Attachment saveAttachment(MultipartFile file, Ticket ticket, String comment, User uploadedBy) throws IOException {
        // Create upload directory if it doesn't exist
        File directory = new File(uploadDir);
        if (!directory.exists()) {
            directory.mkdirs();
        }
        
        // Generate unique filename
        String fileName = UUID.randomUUID().toString() + "_" + file.getOriginalFilename();
        Path filePath = Paths.get(uploadDir + fileName);
        
        // Save file to disk
        Files.write(filePath, file.getBytes());
        
        // Create attachment entity
        Attachment attachment = new Attachment();
        attachment.setFileName(file.getOriginalFilename());
        attachment.setFilePath(filePath.toString());
        attachment.setFileType(file.getContentType());
        attachment.setFileSize(file.getSize());
        attachment.setComment(comment);
        attachment.setTicket(ticket);
        attachment.setUploadedBy(uploadedBy);
        attachment.setUploadedAt(LocalDateTime.now());
        
        return attachmentRepository.save(attachment);
    }
    
    public List<Attachment> getAttachmentsByTicket(Ticket ticket) {
        return attachmentRepository.findByTicket(ticket);
    }
    
    public Attachment findById(Long id) {
        return attachmentRepository.findById(id).orElse(null);
    }
    
    public byte[] downloadAttachment(Long attachmentId) throws IOException {
        Attachment attachment = findById(attachmentId);
        if (attachment != null) {
            Path filePath = Paths.get(attachment.getFilePath());
            return Files.readAllBytes(filePath);
        }
        return null;
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\CommentService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.entity.Comment;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.repository.CommentRepository;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class CommentService {
    private final CommentRepository commentRepository;

    public Comment addComment(Comment comment) {
        comment.setCreatedAt(LocalDateTime.now());
        return commentRepository.save(comment);
    }

    public List<Comment> getCommentsByTicket(Ticket ticket) {
        return commentRepository.findByTicketOrderByCreatedAtAsc(ticket);
    }

    public Comment findById(Long id) {
        return commentRepository.findById(id).orElse(null);
    }
}

--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\TicketCategoryService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import ticketmanagement.ticketservicemanagementv100.entity.TicketCategory;
import ticketmanagement.ticketservicemanagementv100.repository.TicketCategoryRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class TicketCategoryService {
    private final TicketCategoryRepository categoryRepository;
    
    public TicketCategory createCategory(TicketCategory category) {
        if (categoryRepository.existsByName(category.getName())) {
            throw new RuntimeException("Category name already exists");
        }
        return categoryRepository.save(category);
    }
    
    public TicketCategory updateCategory(TicketCategory category) {
        return categoryRepository.save(category);
    }
    
    public void deleteCategory(Long id) {
        categoryRepository.deleteById(id);
    }
    
    public TicketCategory findById(Long id) {
        return categoryRepository.findById(id).orElse(null);
    }
    
    public TicketCategory findByName(String name) {
        return categoryRepository.findByName(name).orElse(null);
    }
    
    public List<TicketCategory> getAllCategories() {
        return categoryRepository.findAll();
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\TicketService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.entity.Ticket;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.TicketStatus;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.TicketRepository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
@RequiredArgsConstructor
public class TicketService {
    private final TicketRepository ticketRepository;
    private final UserService userService;

    public Ticket createTicket(Ticket ticket) {
        ticket.setStatus(TicketStatus.CREATED);
        ticket.setCreatedAt(LocalDateTime.now());
        ticket.setUpdatedAt(LocalDateTime.now());
        return ticketRepository.save(ticket);
    }

    // ADD THIS METHOD for TicketController
    public Ticket createTicket(Long customerId, String description, Long engineerId) {
        User customer = userService.findById(customerId);
        if (customer == null || customer.getRole() != UserRole.CUSTOMER) {
            throw new EntityNotFoundException("Customer not found");
        }

        Ticket ticket = new Ticket();
        ticket.setTitle("Ticket from " + customer.getFullName()); // Auto-generate title
        ticket.setDescription(description);
        ticket.setCustomer(customer);
        ticket.setStatus(TicketStatus.CREATED);

        if (engineerId != null) {
            User engineer = userService.findById(engineerId);
            if (engineer != null && engineer.getRole() == UserRole.ENGINEER) {
                ticket.setAssignedEngineer(engineer);
                ticket.setStatus(TicketStatus.ACKNOWLEDGED);
            }
        }

        return createTicket(ticket);
    }

    public Ticket updateTicket(Ticket ticket) {
        ticket.setUpdatedAt(LocalDateTime.now());
        return ticketRepository.save(ticket);
    }

    public Ticket findById(Long id) {
        return ticketRepository.findById(id).orElse(null);
    }

    public Optional<Ticket> getTicketById(Long id) {
        return ticketRepository.findById(id);
    }


    public List<Ticket> getTicketsForUser(User user) {
        if (user.getRole() == UserRole.CUSTOMER) {
            return ticketRepository.findByCustomer(user);
        } else {
            // For engineers, return both assigned and unassigned tickets
            List<Ticket> assignedTickets = ticketRepository.findByAssignedEngineer(user);
            List<Ticket> unassignedTickets = ticketRepository.findByAssignedEngineerIsNull();
            return Stream.concat(assignedTickets.stream(), unassignedTickets.stream()).collect(Collectors.toList());
        }
    }

    public List<Ticket> getUnassignedTickets() {
        return ticketRepository.findByAssignedEngineerIsNull();
    }

    public List<Ticket> getAssignedTickets(User engineer) {
        return ticketRepository.findByAssignedEngineer(engineer);
    }

    /*
    public Ticket acknowledgeTicket(Long ticketId, User engineer) {
        Ticket ticket = findById(ticketId);
        if (ticket != null && ticket.getAssignedEngineer() == null) {
            ticket.setAssignedEngineer(engineer);
            ticket.setStatus(TicketStatus.ACKNOWLEDGED);
            return updateTicket(ticket);
        }
        return null;
    }*/
    public Ticket acknowledgeTicket(Long ticketId, String engineerUsername) {
        User engineer = userService.findByUsername(engineerUsername);
        if (engineer != null && engineer.getRole() == UserRole.ENGINEER) {
            return acknowledgeTicket(ticketId, engineer);
        }
        return null;
    }

    public Ticket acknowledgeTicketByUser(Long ticketId, User engineer) {
        Ticket ticket = findById(ticketId);
        if (ticket != null && ticket.getAssignedEngineer() == null) {
            ticket.setAssignedEngineer(engineer);
            ticket.setStatus(TicketStatus.ACKNOWLEDGED);
            return updateTicket(ticket);
        }
        return null;
    }


    public List<Ticket> searchTickets(TicketStatus status, Long categoryId, String customerName, User currentUser) {
        if (currentUser.getRole() == UserRole.CUSTOMER) {
            return ticketRepository.findCustomerTicketsWithFilters(currentUser, status, categoryId);
        } else {
            return ticketRepository.findTicketsWithFilters(status, categoryId, customerName);
        }
    }

    public void deleteTicket(Long id) {
        ticketRepository.deleteById(id);
    }

    public List<Ticket> getAllTickets() {
        return ticketRepository.findAll();
    }
}


--- File: src\main\java\ticketmanagement\ticketservicemanagementv100\service\UserService.java ---
package ticketmanagement.ticketservicemanagementv100.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ticketmanagement.ticketservicemanagementv100.entity.User;
import ticketmanagement.ticketservicemanagementv100.enums.UserRole;
import ticketmanagement.ticketservicemanagementv100.repository.UserRepository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;

    public User authenticate(String username, String password) {
        Optional<User> optionalUser = userRepository.findByUsernameAndPassword(username, password);
        if (optionalUser.isPresent()) {
            return optionalUser.get();
        }
        return null;
    }

    public User findById(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    public User findByUsername(String username) {
        return userRepository.findByUsername(username).orElse(null);
    }

    public List<User> findByRole(UserRole role) {
        return userRepository.findByRole(role);
    }

    public User findDefaultEngineer() {
        return userRepository.findByIsDefaultEngineerTrue().orElse(null);
    }

    public boolean isDefaultEngineer(User user) {
        return user != null && Boolean.TRUE.equals(user.getIsDefaultEngineer());
    }

    public User createUser(User user) {
        if (userRepository.existsByUsername(user.getUsername())) {
            throw new RuntimeException("Username already exists");
        }
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new RuntimeException("Email already exists");
        }
        user.setCreatedAt(LocalDateTime.now());
        user.setUpdatedAt(LocalDateTime.now());
        return userRepository.save(user);
    }

    public User updateUser(User user) {
        user.setUpdatedAt(LocalDateTime.now());
        return userRepository.save(user);
    }

    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

}


--- File: src\main\resources\application.properties ---
spring.application.name=ticket-service-management-v100

# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/ticketdb?createDatabaseIfNotExist=true&useSSL=false&allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=root@1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true

# File Upload Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Server Configuration
server.port=8080

# Session Configuration
server.servlet.session.timeout=30m
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=false

# CORS Configuration
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.ticketmanagement.ticketservicemanagementv100=DEBUG
logging.level.org.springframework.web=DEBUG


--- File: src\test\java\ticketmanagement\ticketservicemanagementv100\TicketServiceManagementV100ApplicationTests.java ---
package ticketmanagement.ticketservicemanagementv100;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TicketServiceManagementV100ApplicationTests {

    @Test
    void contextLoads() {
    }

}


--- File: target\classes\application.properties ---
spring.application.name=ticket-service-management-v100

# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/ticketdb?createDatabaseIfNotExist=true&useSSL=false&allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=root@1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true

# File Upload Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Server Configuration
server.port=8080

# Session Configuration
server.servlet.session.timeout=30m
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=false

# CORS Configuration
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.ticketmanagement.ticketservicemanagementv100=DEBUG
logging.level.org.springframework.web=DEBUG
